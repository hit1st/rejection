'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var unicons = _interopDefault(require('unicons'));
var chalk = _interopDefault(require('chalk'));
var Error$1 = _interopDefault(require('es6-error'));
var ansiEscapes = _interopDefault(require('ansi-escapes'));
var cliCursor = _interopDefault(require('cli-cursor'));
var stringWidth = _interopDefault(require('string-width'));
var cliSpinners = _interopDefault(require('cli-spinners'));
var os = require('os');
var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));
var yargs = _interopDefault(require('yargs'));
var _objectSpread = _interopDefault(require('@babel/runtime/helpers/objectSpread'));
var semver = _interopDefault(require('semver'));
var _asyncToGenerator = _interopDefault(require('@babel/runtime/helpers/asyncToGenerator'));
var detectIndent = _interopDefault(require('detect-indent'));
var pify = _interopDefault(require('pify'));
var childProcess = _interopDefault(require('child_process'));
var _slicedToArray = _interopDefault(require('@babel/runtime/helpers/slicedToArray'));
var EventEmitter = _interopDefault(require('events'));

function filterSuccessfulUpdates(results) {
  return results.filter(result => result.success === true);
}

function filterFailedUpdates(results) {
  return results.filter(result => result.success === false);
}

class Message {
  constructor(template, variables) {
    this.template = template;
    this.variables = variables;
  }
  valueOf() {
    const split = this.template.split(/%s/g);

    return split.reduce(
    (str, part, i) => str + part + (this.variables[i] || ""),
    "");

  }
  toString() {
    return this.valueOf();
  }}

const INDICATOR_NEUTRAL = 0;
const INDICATOR_FAIL = 1;
const INDICATOR_PENDING = 2;
const INDICATOR_OK = 3;

const COLORS = [chalk.grey, chalk.red, chalk.yellow, chalk.green];

class Indicator {
  constructor(initialState) {
    this.state = initialState;
  }
  valueOf() {
    return COLORS[this.state](unicons.cli("circle"));
  }
  toString() {
    return this.valueOf();
  }}

// The first value in arrays is the default value

const USE_NPM = "npm";
const USE_YARN = "yarn";
const USE_OPTIONS = [USE_NPM, USE_YARN];
const UPDATE_TO_LATEST = "latest";
const UPDATE_TO_NON_BREAKING = "non-breaking";
const UPDATE_TO_WANTED = "wanted";
const UPDATE_TO_OPTIONS = [
UPDATE_TO_LATEST,
UPDATE_TO_NON_BREAKING,
UPDATE_TO_WANTED];

const SAVE_SMART = "smart";
const SAVE_CARET = "caret";
const SAVE_EXACT = "exact";
const SAVE_OPTIONS = [SAVE_SMART, SAVE_CARET, SAVE_EXACT];

const configNames = {
  use: "use",
  exclude: "exclude",
  test: "test command",
  registry: "registry",
  updateTo: "update to",
  save: "save" };

const configValues = {
  exclude: list => list.join(", ") };

const configFilter = {
  cwd: () => false,
  use: option => option !== USE_OPTIONS[0],
  exclude: list => list.length > 0,
  test: cmd => cmd !== undefined,
  registry: reg => reg !== undefined,
  updateTo: option => option !== UPDATE_TO_OPTIONS[0],
  save: option => option !== SAVE_OPTIONS[0] };


function configList(config) {
  return Object.keys(config).
  filter(key => {
    const filter = configFilter[key];
    const name = configNames[key];

    return (
      name !== undefined && (
      filter === undefined || filter(config[key]) === true));

  }).
  map(key => {
    const toString = configValues[key] || String;

    return `${configNames[key]}: ${toString(config[key])}`;
  });
}

function customConfigToLines(config) {
  const list = configList(config);
  const lines = [];

  if (list.length > 0) {
    lines.push(
    "Running updtr with custom configuration:",
    "",
    ...list.map(item => unicons.cli("circle") + " " + item),
    "");

  }

  return lines;
}

function pluralize(num) {
  return num === 1 ? "" : "s";
}

// Errors are not extendable in node v4.

class PackageJsonNoAccessError extends Error$1 {
  constructor(dir) {
    super(`Cannot access package.json in ${dir}`);
  }}


class RequiredOptionMissingError extends Error$1 {
  constructor(optionName, optionValue) {
    super(
    `Required option ${optionName} is missing. Instead received ${optionValue}`);

  }}


class OptionValueNotSupportedError extends Error$1 {
  constructor(optionName, unsupportedValue) {
    super(`Unsupported value ${unsupportedValue} for option ${optionName}`);
  }}


class YarnWithCustomRegistryError extends Error$1 {
  constructor() {
    super(
    "yarn does not support custom registries yet. Please use a .npmrc file to achieve this");

  }}

const ERROR = chalk.bgRed.bold(" ERROR ");

function handleError(err) {
  const lines = [""];

  switch (err.constructor) {
    case PackageJsonNoAccessError:
      lines.push(
      ERROR + " Cannot find package.json in current directory.");

      break;
    default:{
        // The stack does only contain \n, also on windows
        const stack = err.stack.split("\n");

        stack.shift();
        lines.push(ERROR + " " + err.message);
        lines.push(...stack.map(line => chalk.grey(line)));
      }}

  lines.push("");

  console.error(lines.join("\n"));
  process.exit(1); // eslint-disable-line no-process-exit
}

function msToString(milliseconds) {
  return Math.floor(milliseconds / 1000).toFixed(1) + "s";
}

function updatingLine(updateTask) {
  return [
  new Indicator(INDICATOR_PENDING),
  chalk.bold(updateTask.name),
  chalk.grey("updating"),
  updateTask.rollbackTo,
  chalk.grey(unicons.arrowRight),
  updateTask.updateTo + chalk.grey("...")].
  join(" ");
}

function testingLine(updateTask) {
  return [
  new Indicator(INDICATOR_PENDING),
  chalk.bold(updateTask.name),
  chalk.grey("testing...")].
  join(" ");
}

function rollbackLine(updateTask) {
  return [
  new Indicator(INDICATOR_FAIL),
  chalk.bold.red(updateTask.name),
  chalk.grey("rolling back"),
  updateTask.updateTo,
  chalk.grey(unicons.arrowRight),
  updateTask.rollbackTo + chalk.grey("...")].
  join(" ");
}

function successLine(updateTask) {
  return [
  new Indicator(INDICATOR_OK),
  chalk.bold(updateTask.name),
  updateTask.updateTo,
  chalk.grey("success")].
  join(" ");
}

function failLine(updateTask) {
  return [
  new Indicator(INDICATOR_FAIL),
  chalk.bold.red(updateTask.name),
  updateTask.updateTo,
  chalk.grey("failed")].
  join(" ");
}

function excludedLine(excluded) {
  return [
  new Indicator(INDICATOR_NEUTRAL),
  chalk.bold(excluded.name),
  chalk.grey(excluded.reason)].
  join(" ");
}

function cmdToLines(description, cmd) {
  const lines = Array.isArray(description) === true ?
  description :
  [description];

  return lines.concat([chalk.grey(`> ${cmd} `)]);
}

function writeLinesToConsole(lines) {
  if (lines.length === 0) {
    return;
  }
  console.log(ansiEscapes.eraseDown + lines.join("\n"));
}

function basic(updtr, reporterConfig) {
  const startTime = Date.now();
  let excludedModules;

  updtr.on("start", ({ config }) => {
    writeLinesToConsole(customConfigToLines(config));
  });
  updtr.on("init/install-missing", ({ cmd }) => {
    writeLinesToConsole(
    cmdToLines(
    "Installing missing dependencies" + chalk.grey("..."),
    cmd));


  });
  updtr.on("init/collect", ({ cmd }) => {
    writeLinesToConsole(
    cmdToLines("Looking for outdated modules" + chalk.grey("..."), cmd));

  });
  updtr.on("init/end", ({ updateTasks, excluded }) => {
    excludedModules = excluded;
    if (updateTasks.length === 0 && excluded.length === 0) {
      writeLinesToConsole(["Everything " + chalk.bold("up-to-date")]);
    } else if (updateTasks.length === 0) {
      writeLinesToConsole([
      chalk.bold("No updates available") +
      " for the given modules and version range"]);

    } else {
      writeLinesToConsole([
      new Message("Found " + chalk.bold("%s update%s") + ".", [
      updateTasks.length,
      pluralize(updateTasks.length)]),

      ""]);

    }
  });
  updtr.on("batch-update/updating", event => {
    writeLinesToConsole(
    cmdToLines(event.updateTasks.map(updatingLine), event.cmd));

  });
  updtr.on("batch-update/testing", event => {
    writeLinesToConsole(
    cmdToLines(event.updateTasks.map(testingLine), event.cmd));

  });
  updtr.on("batch-update/rollback", event => {
    writeLinesToConsole(
    cmdToLines(event.updateTasks.map(rollbackLine), event.cmd));

  });
  updtr.on("batch-update/result", event => {
    if (event.success === true) {
      writeLinesToConsole(
      event.updateTasks.map(event.success ? successLine : failLine));

    }
    // Not showing the test stdout here when there was an error because
    // we will proceed with the sequential update.
  });
  updtr.on("sequential-update/updating", event => {
    writeLinesToConsole(cmdToLines(updatingLine(event), event.cmd));
  });
  updtr.on("sequential-update/testing", event => {
    writeLinesToConsole(cmdToLines(testingLine(event), event.cmd));
  });
  updtr.on("sequential-update/rollback", event => {
    writeLinesToConsole(cmdToLines(rollbackLine(event), event.cmd));
  });
  updtr.on("sequential-update/result", event => {
    writeLinesToConsole([(event.success ? successLine : failLine)(event)]);
    if (reporterConfig.testStdout === true && event.success === false) {
      writeLinesToConsole([event.stdout]);
    }
  });
  updtr.on("end", ({ results }) => {
    const duration = msToString(Date.now() - startTime);
    const successful = filterSuccessfulUpdates(results);
    const failed = filterFailedUpdates(results);

    writeLinesToConsole([""]);

    if (successful.length > 0) {
      writeLinesToConsole([
      new Message(chalk.bold("%s successful") + " update%s.", [
      successful.length,
      pluralize(successful.length)])]);


    }
    if (failed.length > 0) {
      writeLinesToConsole([
      new Message(chalk.bold("%s failed") + " update%s.", [
      failed.length,
      pluralize(failed.length)])]);


    }
    if (excludedModules.length > 0) {
      const list = excludedModules.map(excludedLine);

      if (successful.length > 0 || failed.length > 0) {
        writeLinesToConsole([""]);
      }
      writeLinesToConsole(
      [
      new Message(chalk.bold("%s skipped") + " module%s:", [
      excludedModules.length,
      pluralize(excludedModules.length)]),

      ""].
      concat(list));

    }

    writeLinesToConsole(["", new Message("Finished after %s.", [duration])]);
  });
  updtr.on("error", err => void handleError(err));
}

function lineToString(line) {
  if (Array.isArray(line) === true) {
    return line.join("");
  }

  return String(line);
}

class Projector {
  constructor(terminal, frameRate = 10) {
    this.terminal = terminal;
    this.delay = Math.floor(1000 / frameRate);
    this.timeoutId = null;
  }
  display(frame) {
    if (this.timeoutId !== null) {
      this.stop();
    }
    this.terminal.append(frame.map(lineToString));
    this.timeoutId = setTimeout(() => {
      this.display(frame);
    }, this.delay);
  }
  stop() {
    if (this.timeoutId === null) {
      return;
    }
    this.terminal.rewind();
    clearTimeout(this.timeoutId);
    this.timeoutId = null;
  }}

function calcNumOfRows(lines, columns) {
  return lines.
  map(lineContent => Math.ceil(stringWidth(lineContent) / columns)).
  reduce((allRows, rows) => allRows + rows, 0);
}

// Solves some issues where stdout output is truncated
// See https://github.com/nodejs/node/issues/6456
function setBlocking(stream) {
  if (stream._handle && typeof stream._handle.setBlocking === "function") {
    stream._handle.setBlocking(true);
  }
}

class Terminal {
  constructor(stream) {
    if (stream.isTTY !== true) {
      throw new Error("Given stream is not a TTY stream");
    }
    setBlocking(stream);
    cliCursor.hide(stream);
    this.stream = stream;
    this.lines = [];
    this.hasBeenResized = false;
    this.stream.on("resize", () => {
      this.hasBeenResized = true;
    });
  }
  append(lines) {
    if (lines.length === 0) {
      return;
    }
    this.lines.push(lines);

    const content = this.hasBeenResized === true ?
    ansiEscapes.clearScreen +
    this.lines.map(lines => lines.join("\n")).join("\n") :
    ansiEscapes.eraseDown + lines.join("\n");

    this.stream.write(content + "\n");
    this.hasBeenResized = false;
  }
  rewind() {
    const removedLines = this.lines.pop();
    const rows = calcNumOfRows(removedLines, this.stream.columns);

    this.stream.write(ansiEscapes.cursorUp(rows));
  }}

const isWin = process.platform === "win32";
const winFallback = "simpleDotsScrolling";

class Spinner {
  constructor(spinnerName) {
    const spinner = cliSpinners[isWin === true ? winFallback : spinnerName];

    this.frames = spinner.frames;
    this.interval = spinner.interval;
    this.length = Math.max(...this.frames.map(frame => frame.length));
  }
  valueOf() {
    const currentInterval = Math.floor(Date.now() / this.interval);
    const currentFrame = currentInterval % this.frames.length;

    return this.frames[currentFrame];
  }
  toString() {
    return this.valueOf();
  }}

const spinner = new Spinner("dots");

function updatingLine$1(updateTask) {
  return [
  new Indicator(INDICATOR_PENDING),
  chalk.bold(updateTask.name),
  chalk.grey("updating"),
  updateTask.rollbackTo,
  chalk.grey(unicons.arrowRight),
  updateTask.updateTo + chalk.grey("...")].
  join(" ");
}

function testingLine$1(updateTask) {
  return [
  new Indicator(INDICATOR_PENDING),
  chalk.bold(updateTask.name),
  chalk.grey("testing...")].
  join(" ");
}

function rollbackLine$1(updateTask) {
  return [
  new Indicator(INDICATOR_FAIL),
  chalk.bold.red(updateTask.name),
  chalk.grey("rolling back"),
  updateTask.updateTo,
  chalk.grey(unicons.arrowRight),
  updateTask.rollbackTo + chalk.grey("...")].
  join(" ");
}

function successLine$1(updateTask) {
  return [
  new Indicator(INDICATOR_OK),
  chalk.bold(updateTask.name),
  updateTask.updateTo,
  chalk.grey("success")].
  join(" ");
}

function failLine$1(updateTask) {
  return [
  new Indicator(INDICATOR_FAIL),
  chalk.bold.red(updateTask.name),
  updateTask.updateTo,
  chalk.grey("failed")].
  join(" ");
}

function excludedLine$1(excluded) {
  return [
  new Indicator(INDICATOR_NEUTRAL),
  chalk.bold(excluded.name),
  chalk.grey(excluded.reason)].
  join(" ");
}

function cmdToLines$1(description, cmd) {
  const lines = Array.isArray(description) === true ?
  description :
  [description];

  return lines.concat([chalk.grey(`> ${cmd} `), spinner]);
}

function dense(updtr, reporterConfig) {
  const terminal = new Terminal(reporterConfig.stream);
  const projector = new Projector(terminal);
  const startTime = Date.now();
  let excludedModules;

  updtr.on("start", ({ config }) => {
    terminal.append(customConfigToLines(config));
  });
  updtr.on("init/install-missing", ({ cmd }) => {
    projector.display(
    cmdToLines$1(
    "Installing missing dependencies" + chalk.grey("..."),
    cmd));


  });
  updtr.on("init/collect", ({ cmd }) => {
    projector.display(
    cmdToLines$1("Looking for outdated modules" + chalk.grey("..."), cmd));

  });
  updtr.on("init/end", ({ updateTasks, excluded }) => {
    excludedModules = excluded;
    projector.stop();
    if (updateTasks.length === 0 && excluded.length === 0) {
      terminal.append(["Everything " + chalk.bold("up-to-date")]);
    } else if (updateTasks.length === 0) {
      terminal.append([
      chalk.bold("No updates available") +
      " for the given modules and version range"]);

    } else {
      terminal.append([
      new Message("Found " + chalk.bold("%s update%s") + ".", [
      updateTasks.length,
      pluralize(updateTasks.length)]),

      ""]);

    }
  });
  updtr.on("batch-update/updating", event => {
    projector.display(
    cmdToLines$1(event.updateTasks.map(updatingLine$1), event.cmd));

  });
  updtr.on("batch-update/testing", event => {
    projector.display(
    cmdToLines$1(event.updateTasks.map(testingLine$1), event.cmd));

  });
  updtr.on("batch-update/rollback", event => {
    projector.display(
    cmdToLines$1(event.updateTasks.map(rollbackLine$1), event.cmd));

  });
  updtr.on("batch-update/result", event => {
    projector.stop();
    if (event.success === true) {
      terminal.append(
      event.updateTasks.map(event.success ? successLine$1 : failLine$1));

    }
    // Not showing the test stdout here when there was an error because
    // we will proceed with the sequential update.
  });
  updtr.on("sequential-update/updating", event => {
    projector.display(cmdToLines$1(updatingLine$1(event), event.cmd));
  });
  updtr.on("sequential-update/testing", event => {
    projector.display(cmdToLines$1(testingLine$1(event), event.cmd));
  });
  updtr.on("sequential-update/rollback", event => {
    projector.display(cmdToLines$1(rollbackLine$1(event), event.cmd));
  });
  updtr.on("sequential-update/result", event => {
    projector.stop();
    terminal.append([(event.success ? successLine$1 : failLine$1)(event)]);
    if (reporterConfig.testStdout === true && event.success === false) {
      terminal.append([event.stdout]);
    }
  });
  updtr.on("end", ({ results }) => {
    const duration = msToString(Date.now() - startTime);
    const successful = filterSuccessfulUpdates(results);
    const failed = filterFailedUpdates(results);

    terminal.append([""]);

    if (successful.length > 0) {
      terminal.append([
      new Message(chalk.bold("%s successful") + " update%s.", [
      successful.length,
      pluralize(successful.length)])]);


    }
    if (failed.length > 0) {
      terminal.append([
      new Message(chalk.bold("%s failed") + " update%s.", [
      failed.length,
      pluralize(failed.length)])]);


    }
    if (excludedModules.length > 0) {
      const list = excludedModules.map(excludedLine$1);

      if (successful.length > 0 || failed.length > 0) {
        terminal.append([""]);
      }
      terminal.append(
      [
      new Message(chalk.bold("%s skipped") + " module%s:", [
      excludedModules.length,
      pluralize(excludedModules.length)]),

      ""].
      concat(list));

    }

    terminal.append(["", new Message("Finished after %s.", [duration])]);
  });
  updtr.on("error", err => void handleError(err));
}

var none = Function.prototype;

// The first property here is the default reporter
const reporters = { dense, basic, none };

const reporterNames = Object.keys(reporters);
const pathToYarnLock = path.join(process.cwd(), "yarn.lock");
const useDefault = fs.existsSync(pathToYarnLock) === true ? USE_YARN : USE_NPM;

var argv = yargs.
usage(
[
"",
chalk.bold.cyan("Update outdated npm modules with zero pain™"),
`${chalk.bold("Usage:")} $0 ${chalk.dim("[options]")}`].
join(os.EOL)).

option("use", {
  describe: "Specify the package manager to use",
  choices: USE_OPTIONS,
  default: useDefault,
  alias: "u" }).

option("exclude", {
  describe: "Space separated list of module names that should not be updated",
  array: true,
  alias: "ex" }).

option("update-to", {
  describe: "Specify which updates you want to install",
  choices: UPDATE_TO_OPTIONS,
  default: UPDATE_TO_OPTIONS[0],
  alias: "to" }).

option("save", {
  describe: "Specify how updated versions should be saved to the package.json",
  choices: SAVE_OPTIONS,
  default: SAVE_OPTIONS[0],
  alias: "s" }).

option("reporter", {
  describe: "Choose a reporter for the console output",
  choices: reporterNames,
  default: reporterNames[0],
  alias: "r" }).

option("test", {
  describe: "Specify a custom test command. Surround with quotes.",
  alias: "t" }).

option("test-stdout", {
  describe: "Show test stdout if the update fails",
  boolean: true,
  default: false,
  alias: "out" }).

option("registry", {
  describe: "Specify a custom registry to use",
  alias: "reg" }).

version().
wrap(null).
help().argv;

class Sequence {
  constructor(name, updtr, baseEvent = {}) {
    this.name = name;
    this.updtr = updtr;
    this.baseEvent = baseEvent;
    this.isRunning = false;
  }
  start() {
    this.isRunning = true;
    this.emit("start");
  }
  emit(eventName, event = {}) {
    const fullEventName = this.name + "/" + eventName;

    if (this.isRunning === false) {
      throw new Error(
      `Cannot emit event ${fullEventName}: sequence is not running`);

    }
    this.updtr.emit(fullEventName, _objectSpread({},
    this.baseEvent,
    event));

  }
  exec(step, cmd) {
    this.emit(step, { cmd });

    return this.updtr.exec(cmd);
  }
  end(result) {
    this.emit("end", result);
    this.isRunning = false;
  }}

function determineUpdateToVersion({ current, wanted, latest }, { updateTo }) {
  switch (updateTo) {
    case UPDATE_TO_LATEST:
      return latest;
    case UPDATE_TO_WANTED:
      return wanted;
    case UPDATE_TO_NON_BREAKING:
    default:
      return "^" + current;}

}

function isUpdateToNonBreaking(updateTask) {
  return updateTask.updateTo === "^" + updateTask.rollbackTo;
}

function createUpdateTask(outdated, updtrConfig) {
  return {
    name: outdated.name,
    updateTo: determineUpdateToVersion(outdated, updtrConfig),
    rollbackTo: outdated.current };

}

const GIT = "git";
const EXOTIC = "exotic";
const UNSTABLE = "unstable";
const EXCLUDED = "excluded";
const NOT_WANTED = "not-wanted";

const prePattern = /^pre/;
const reasonTests = [
{
  name: EXCLUDED,
  test: (updateTask, { exclude }) =>
  exclude.some(name => updateTask.name === name) === true },

{
  name: GIT,
  test: updateTask => updateTask.updateTo === "git" },

{
  name: EXOTIC,
  test: updateTask => updateTask.updateTo === "exotic" },

{
  name: NOT_WANTED,
  test: updateTask =>
  isUpdateToNonBreaking(updateTask) === false &&
  semver.lte(updateTask.updateTo, updateTask.rollbackTo) === true },

{
  name: UNSTABLE,
  test(updateTask) {
    if (isUpdateToNonBreaking(updateTask) === true) {
      return null;
    }

    const diff = semver.diff(
    updateTask.rollbackTo,
    updateTask.updateTo);

    const unstableTest = diff !== null &&
    prePattern.test(diff) === true &&
    diff !== "prerelease";

    return unstableTest === true;
  } }];


const reasons = reasonTests.map(test => test.name);

function filterUpdateTask(updateTask, updtrConfig) {
  const reasonIndex = reasonTests.findIndex(
  reasonTest => reasonTest.test(updateTask, updtrConfig) === true);


  return reasonIndex === -1 ? null : reasons[reasonIndex];
}

function getUpdateTasksFromStdout(updtr, outdatedCmd, stdout) {
  if (stdout.length === 0) {
    // When there is not stdout, there is nothing to update
    return [];
  }

  return updtr.parse.
  outdated(stdout, outdatedCmd).
  map(outdated => createUpdateTask(outdated, updtr.config));
}

var init = /*#__PURE__*/(function () {var _init = _asyncToGenerator(function* (updtr) {
    const baseEvent = { config: updtr.config };
    const outdatedCmd = updtr.cmds.outdated();
    const sequence = new Sequence("init", updtr, baseEvent);
    let stdout;

    sequence.start();

    if ((yield updtr.canAccessPackageJson()) === false) {
      throw new PackageJsonNoAccessError(updtr.config.cwd);
    }

    yield sequence.exec(
    "install-missing",
    updtr.cmds.installMissing({
      registry: updtr.config.registry }));



    try {
      stdout = (yield sequence.exec("collect", outdatedCmd)).stdout;
    } catch (err) {
      // npm exits with zero code 1 when there are outdated dependencies
      // We don't check for the package manager here because yarn might change their
      // behavior in the future to be npm-compatible.
      if (err.code > 1) {
        throw err;
      }

      stdout = err.stdout;
    }

    const allUpdateTasks = getUpdateTasksFromStdout(
    updtr,
    outdatedCmd,
    stdout.trim());

    const filterResults = allUpdateTasks.map(updateTask =>
    filterUpdateTask(updateTask, updtr.config));
    const result = {
      updateTasks: allUpdateTasks.filter(
      (updateTask, index) => filterResults[index] === null),

      excluded: allUpdateTasks.reduce(
      (excluded, updateTask, index) => {
        const reason = filterResults[index];

        if (reason === null) {
          return excluded;
        }

        return excluded.concat(_objectSpread({},
        updateTask, {
          reason }));

      },
      []) };



    sequence.end(result);

    return result;
  });return function init(_x) {return _init.apply(this, arguments);};})();

function createUpdateResult(updateTask, success) {
  return {
    name: updateTask.name,
    updateTo: updateTask.updateTo,
    rollbackTo: updateTask.rollbackTo,
    success };

}

function updateTo(updateTask) {
  return {
    name: updateTask.name,
    version: updateTask.updateTo };

}

function rollbackTo(updateTask) {
  return {
    name: updateTask.name,
    version: updateTask.rollbackTo };

}

function renderUpdate(updtr, updateTask) {
  return updtr.cmds.install({
    registry: updtr.config.registry,
    modules: [updateTo(updateTask)] });

}

function renderTest(updtr) {
  return updtr.cmds.test();
}

function renderRollback(updtr, failedUpdateTask, nextUpdateTask) {
  const modules = [rollbackTo(failedUpdateTask)];

  if (nextUpdateTask !== undefined) {
    modules.push(updateTo(nextUpdateTask));
  }

  return updtr.cmds.install({
    registry: updtr.config.registry,
    modules });

}function

runUpdateTask(_x, _x2, _x3, _x4) {return _runUpdateTask.apply(this, arguments);}function _runUpdateTask() {_runUpdateTask = _asyncToGenerator(function* (sequence, updateTasks, i, previousUpdateResults) {
    const updateResults = yield previousUpdateResults;
    const previousUpdateResult = updateResults[updateResults.length - 1];
    const updateTask = updateTasks[i];
    // If the previous update was a failure, we don't need to update now because
    // during the rollback, the next update is also installed in parallel
    const updateNecessary = previousUpdateResult === undefined ?
    true :
    previousUpdateResult.success === true;

    sequence.baseEvent = _objectSpread({
      updateTasks: {
        current: i + 1,
        total: updateTasks.length } },

    updateTask);

    const updtr = sequence.updtr;
    let testResult;
    let success;

    if (updateNecessary === true) {
      yield sequence.exec("updating", renderUpdate(updtr, updateTask));
    }

    try {
      testResult = yield sequence.exec("testing", renderTest(updtr));
      success = true;
    } catch (err) {
      // Remember: instanceof Error might not work in Jest as expected
      // https://github.com/facebook/jest/issues/2549
      testResult = err;
      success = false;
    }

    sequence.baseEvent.success = success;

    if (success === false) {
      const nextUpdateTask = i + 1 < updateTasks.length ?
      updateTasks[i + 1] :
      undefined;

      yield sequence.exec(
      "rollback",
      renderRollback(updtr, updateTask, nextUpdateTask));

    }

    sequence.emit("result", {
      stdout: testResult.stdout });


    return updateResults.concat(createUpdateResult(updateTask, success));
  });return _runUpdateTask.apply(this, arguments);}

var sequentialUpdate = /*#__PURE__*/(function () {var _sequentialUpdate = _asyncToGenerator(function* (
  updtr,
  updateTasks,
  previousUpdateResult)
  {
    const sequence = new Sequence("sequential-update", updtr, {
      updateTasks });


    if (updateTasks.length === 0) {
      return [];
    }

    sequence.start();

    const updateResults = yield updateTasks.reduce(
    (updateResults, updateTask, i) =>
    runUpdateTask(sequence, updateTasks, i, updateResults),
    previousUpdateResult === undefined ? [] : [previousUpdateResult]);


    if (previousUpdateResult !== undefined) {
      // The previousUpdateResult is the first element in the updateResults array, so let's remove it.
      updateResults.shift();
    }

    sequence.baseEvent = {
      updateResults };


    sequence.end();

    return updateResults;
  });return function sequentialUpdate(_x5, _x6, _x7) {return _sequentialUpdate.apply(this, arguments);};})();

function isBreaking(updateTask) {
  return isUpdateToNonBreaking(updateTask) === false &&
  semver.satisfies(updateTask.updateTo, "^" + updateTask.rollbackTo) ===
  false;
}

function splitUpdateTask(updateTasks) {
  const breaking = [];
  const nonBreaking = [];var _iteratorNormalCompletion = true;var _didIteratorError = false;var _iteratorError = undefined;try {

    for (var _iterator = updateTasks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {const updateTask = _step.value;
      (isBreaking(updateTask) === true ? breaking : nonBreaking).push(
      updateTask);

    }} catch (err) {_didIteratorError = true;_iteratorError = err;} finally {try {if (!_iteratorNormalCompletion && _iterator.return != null) {_iterator.return();}} finally {if (_didIteratorError) {throw _iteratorError;}}}

  return {
    breaking,
    nonBreaking };

}

function renderUpdate$1(updtr, updateTask) {
  return updtr.cmds.install({
    registry: updtr.config.registry,
    modules: updateTask.map(updateTo) });

}

function renderTest$1(updtr) {
  return updtr.cmds.test();
}

function renderRollback$1(updtr, failedUpdateTasks) {
  return updtr.cmds.install({
    registry: updtr.config.registry,
    modules: failedUpdateTasks.map(rollbackTo) });

}function

update(_x, _x2) {return _update.apply(this, arguments);}function _update() {_update = _asyncToGenerator(function* (sequence, updateTasks) {
    const updtr = sequence.updtr;
    let success;
    let testResult;

    yield sequence.exec("updating", renderUpdate$1(updtr, updateTasks));
    try {
      testResult = yield sequence.exec("testing", renderTest$1(updtr));
      success = true;
    } catch (err) {
      // Remember: instanceof Error might not work in Jest as expected
      // https://github.com/facebook/jest/issues/2549
      testResult = err;
      success = false;
    }

    sequence.baseEvent.success = success;

    if (success === false && updateTasks.length > 1) {
      // If the update was a failure, we roll back every update except the first.
      // The first update will be tested with the sequential-update. This way we skip one unnecessary install cycle.
      yield sequence.exec(
      "rollback",
      renderRollback$1(updtr, updateTasks.slice(1)));

    }

    sequence.emit("result", {
      stdout: testResult.stdout });


    return success;
  });return _update.apply(this, arguments);}

var batchUpdate = /*#__PURE__*/(function () {var _batchUpdate = _asyncToGenerator(function* (updtr, updateTasks) {
    const sequence = new Sequence("batch-update", updtr, {
      updateTasks });

    let success = true;

    if (updateTasks.length > 0) {
      sequence.start();
      success = yield update(sequence, updateTasks);
      sequence.baseEvent = {
        success };

      sequence.end();
    }

    return success;
  });return function batchUpdate(_x3, _x4) {return _batchUpdate.apply(this, arguments);};})();

function isIncompleteResult(result) {
  return result.success === true && isUpdateToNonBreaking(result) === true;
}function

finishIncomplete(_x, _x2, _x3) {return _finishIncomplete.apply(this, arguments);}function _finishIncomplete() {_finishIncomplete = _asyncToGenerator(function* (sequence, incomplete, allResults) {
    const updtr = sequence.updtr;
    const modulesToCheck = incomplete.map(result => result.name);
    const listCmd = updtr.cmds.list({ modules: modulesToCheck });
    let stdout;

    try {
      stdout = (yield sequence.exec("list-incomplete", listCmd)).stdout;
    } catch (err) {
      // npm may exit with zero code 1 complaining about invalid installed versions
      if (err.code > 1) {
        throw err;
      }
      stdout = err.stdout;
    }
    const moduleVersions = updtr.parse.list(stdout, listCmd);

    return (
      allResults.
      map(result => {
        if (isIncompleteResult(result) === false) {
          return result;
        }

        const version = moduleVersions.find(
        module => module.name === result.name).
        version;

        return _objectSpread({},
        result, {
          updateTo: version });

      })
      // Remove results where no actual update did happen.
      // These results can happen if the updateTo option was set to non-breaking
      // and the module did not have a new version for the rollbackTo version range.
      .filter(result => result.rollbackTo !== result.updateTo));

  });return _finishIncomplete.apply(this, arguments);}

var finish = /*#__PURE__*/(function () {var _finish = _asyncToGenerator(function* (updtr, results) {
    const incomplete = results.filter(isIncompleteResult);
    const sequence = new Sequence("finish", updtr);
    let finishedResults = results;

    if (incomplete.length > 0) {
      sequence.start();
      sequence.emit("incomplete", { incomplete });
      finishedResults = yield finishIncomplete(sequence, incomplete, results);
      sequence.end({ results: finishedResults });
    }

    return finishedResults;
  });return function finish(_x4, _x5) {return _finish.apply(this, arguments);};})();

// Matches a semver version range that can be transformed to the new version in a safe manner
const expectedSemverPattern = /^(\^|~|>=|)(\d+)\.(\d+|x|\*)\.(\d+|x|\*)(-[a-z][a-z\-.\d]+|)$/i;
const numberPattern = /^\d+$/;

function parse(semverString) {
  const match = semverString.match(expectedSemverPattern);

  return match === null ?
  null :
  {
    operator: match[1],
    major: match[2],
    minor: match[3],
    patch: match[4],
    release: match[5] };

}

function isPinned({ operator, major, minor, patch }) {
  return operator === "" &&
  [major, minor, patch].every(
  version => numberPattern.test(version) === true);

}

function tryVersionRangeUpdate(parsedOldRange, parsedNewVersion) {const
  minor = parsedOldRange.minor,patch = parsedOldRange.patch,operator = parsedOldRange.operator;
  let newMinor = parsedNewVersion.minor;
  let newPatch = parsedNewVersion.patch;

  if (numberPattern.test(minor) === false) {
    newMinor = minor;
    newPatch = numberPattern.test(patch) === true ? minor : patch;
  } else if (numberPattern.test(patch) === false) {
    newPatch = patch;
  }

  return operator +
  parsedNewVersion.major +
  "." +
  newMinor +
  "." +
  newPatch +
  parsedNewVersion.release;
}

function isExpectedNewVersion(parsedNewVersion) {
  return parsedNewVersion !== null && parsedNewVersion.operator === "";
}

function fallbackRange(newVersion) {
  return "^" + newVersion;
}

/**
   * Tries to apply the newVersion while maintaining the range (see https://github.com/peerigon/updtr/issues/47)
   * This is kind of risky because there are tons of semver possibilities. That's why this
   * function is very conservative in accepting semver ranges. If the range is not easily updatable,
   * we opt-out to npm's default caret operator.
   *
   * @param {string} oldRange
   * @param {string} newVersion
   * @returns {string}
   */
function updateVersionRange(oldRange, newVersion) {
  const parsedOldRange = parse(oldRange.trim());

  if (parsedOldRange !== null) {
    if (isPinned(parsedOldRange) === true) {
      // The old version was pinned, so the new should also be pinned
      return newVersion;
    }

    const parsedNewVersion = parse(newVersion);

    if (isExpectedNewVersion(parsedNewVersion) === false) {
      return newVersion;
    }

    const newVersionRange = tryVersionRangeUpdate(
    parsedOldRange,
    parsedNewVersion);


    // All this is kind of error prone so let's do a sanity check if everything's ok
    if (semver.satisfies(newVersion, newVersionRange) === true) {
      return newVersionRange;
    }
  }

  return fallbackRange(newVersion);
}

const dependencyTypes = [
"dependencies",
"devDependencies",
"optionalDependencies"];


function newVersionRange(updtrConfig, oldVersionRange, update) {
  switch (updtrConfig.save) {
    case SAVE_CARET:
      return "^" + update.updateTo;
    case SAVE_EXACT:
      return update.updateTo;
    case SAVE_SMART:}


  return updateVersionRange(oldVersionRange, update.updateTo);
}

function createUpdatedPackageJson(
oldPackageJson,
updateResults,
updtrConfig)
{
  const newPackageJson = _objectSpread({}, oldPackageJson);
  const successfulUpdates = filterSuccessfulUpdates(updateResults);
  let dependenciesToSave = successfulUpdates;

  dependencyTypes.
  filter(type => oldPackageJson[type] !== undefined).
  forEach(type => {
    const dependencies = oldPackageJson[type];
    const newDependencies = {};

    Object.keys(dependencies).forEach(moduleName => {
      const update = successfulUpdates.find(
      ({ name }) => name === moduleName);

      const oldVersionRange = dependencies[moduleName];

      newDependencies[moduleName] = update === undefined ?
      oldVersionRange :
      newVersionRange(updtrConfig, oldVersionRange, update);

      dependenciesToSave = dependenciesToSave.filter(
      ({ name }) => name !== moduleName);

    });

    newPackageJson[type] = newDependencies;
  });

  if (dependenciesToSave.length > 0) {
    const dependencies = newPackageJson.dependencies || {};

    dependenciesToSave.forEach(update => {
      dependencies[update.name] = update.updateTo;
    });

    newPackageJson.dependencies = dependencies;
  }

  return newPackageJson;
}

function lastChar(str) {
  return str.charAt(str.length - 1);
}

function stringify(newPackageJson, oldPackageJsonStr) {
  const indent = detectIndent(oldPackageJsonStr).indent || "  ";
  let newPackageJsonStr = JSON.stringify(newPackageJson, null, indent);
  const lastCharFromOldPackageJson = lastChar(oldPackageJsonStr);

  // Preserve the new line character at the end if there was one
  if (lastCharFromOldPackageJson !== lastChar(newPackageJsonStr)) {
    newPackageJsonStr += lastCharFromOldPackageJson;
  }

  return newPackageJsonStr;
}function

enhanceErrorMessage(_x, _x2) {return _enhanceErrorMessage.apply(this, arguments);}function _enhanceErrorMessage() {_enhanceErrorMessage = _asyncToGenerator(function* (fn, enhancedMessage) {
    try {
      return yield fn();
    } catch (err) {
      err.message = enhancedMessage + err.message;
      throw err;
    }
  });return _enhanceErrorMessage.apply(this, arguments);}

var updatePackageJson = /*#__PURE__*/(function () {var _updatePackageJson = _asyncToGenerator(function* (updtr, updateResults) {
    const sequence = new Sequence("update-package-json", updtr);
    let oldPackageJsonStr;

    sequence.start();

    const oldPackageJson = yield enhanceErrorMessage( /*#__PURE__*/_asyncToGenerator(
    function* () {
      oldPackageJsonStr = yield updtr.readFile("package.json");

      return JSON.parse(oldPackageJsonStr);
    }),
    "Error while trying to read the package.json: ");

    const newPackageJson = createUpdatedPackageJson(
    oldPackageJson,
    updateResults,
    updtr.config);


    yield enhanceErrorMessage(
    () =>
    updtr.writeFile(
    "package.json",
    stringify(newPackageJson, oldPackageJsonStr)),

    "Error while trying to write the package.json: ");


    sequence.end({
      packageJson: newPackageJson });

  });return function updatePackageJson(_x3, _x4) {return _updatePackageJson.apply(this, arguments);};})();

function

runUpdateTasks(_x, _x2) {return _runUpdateTasks.apply(this, arguments);}function _runUpdateTasks() {_runUpdateTasks = _asyncToGenerator(function* (updtr, updateTasks) {
    const results = [];const _splitUpdateTasks =
    splitUpdateTask(updateTasks),breaking = _splitUpdateTasks.breaking,nonBreaking = _splitUpdateTasks.nonBreaking;
    const sequentialUpdateTasks = breaking.slice();
    let batchSuccess; // can be undefined, true or false
    let batchUpdateFailure;

    // Run batch update if we have more than one non-breaking update
    // If the batch update fails, it will roll back all modules except the first one.
    // This way we can skip one install command since we will run the sequential update for it anyway.
    if (nonBreaking.length > 1) {
      batchSuccess = yield batchUpdate(updtr, nonBreaking);
    }

    if (batchSuccess === true) {
      results.push(
      ...nonBreaking.map(updateTask =>
      createUpdateResult(updateTask, true)));


    } else {
      sequentialUpdateTasks.unshift(...nonBreaking);
      // If batchSuccess is false, we have actually executed the batch update and it returned false
      if (batchSuccess === false) {
        batchUpdateFailure = createUpdateResult(nonBreaking[0], false);
      }
    }

    // Run sequential update for all breaking updates and non-breaking batch updates that failed
    results.push(
    ...(yield sequentialUpdate(
    updtr,
    sequentialUpdateTasks,
    batchUpdateFailure)));



    return finish(updtr, results);
  });return _runUpdateTasks.apply(this, arguments);}

var run = /*#__PURE__*/(function () {var _run = _asyncToGenerator(function* (updtr) {
    const results = [];

    updtr.emit("start", {
      config: updtr.config });const _ref = yield (


      init(updtr)),updateTasks = _ref.updateTasks;

    if (updateTasks.length > 0) {
      results.push(...(yield runUpdateTasks(updtr, updateTasks)));
      yield updatePackageJson(updtr, results);
    }

    updtr.emit("end", {
      config: updtr.config,
      results });


    return results;
  });return function run(_x3) {return _run.apply(this, arguments);};})();

var fs$1 = pify(fs);

function promiseExec(cwd, cmd) {
  return new Promise(resolve => {
    childProcess.exec(
    cmd,
    { maxBuffer: Infinity, encoding: "utf8", cwd },
    // We need to use the callback API here
    (err, stdout, stderr) => void resolve({ err, stdout, stderr }) // eslint-disable-line promise/prefer-await-to-callbacks
    );
  });
}

var exec = /*#__PURE__*/(function () {var _exec = _asyncToGenerator(function* (cwd, cmd) {const _ref = yield (
      promiseExec(cwd, cmd)),err = _ref.err,stdout = _ref.stdout,stderr = _ref.stderr;

    if (err !== null) {
      err.stdout = stdout;
      err.stderr = stderr;

      throw err;
    }

    return { stdout, stderr };
  });return function exec(_x, _x2) {return _exec.apply(this, arguments);};})();

function installFn(baseCmd) {
  return ({ registry, modules } = {}) =>
  [baseCmd, stringifyRegistry(registry), stringifyModules(modules)].join(
  "");

}

function stringifyModules(modules) {
  return Array.isArray(modules) === true ?
  " " +
  modules
  // We need to wrap this in double-quotes because some semver
  // characters like the caret symbol are reserved characters on Windows.
  .map(({ name, version }) => `"${name}@${version}"`).
  join(" ") :
  "";
}

function stringifyRegistry(registry) {
  return registry === undefined ? "" : ` --registry "${registry}"`;
}

const cmds = {
  npm: {
    outdated: () => "npm outdated --json --depth=0",
    installMissing: installFn("npm install"),
    install: installFn("npm install"),
    // remove: ({ name }) => ["npm remove ", name].join(""),
    test: () => "npm test",
    list: ({ modules } = {}) => [
    "npm ls --json --depth=0",
    Array.isArray(modules) === true ? " " + modules.join(" ") : ""].
    join("") },

  // yarn does not support custom registries yet.
  // However, these renderers accept them anyway.
  yarn: {
    outdated: () => "yarn outdated --json --flat",
    installMissing: installFn("yarn"),
    install: installFn("yarn add"),
    // remove: ({ name }) => ["yarn remove ", name].join(""),
    test: () => "yarn test",
    list: ({ modules } = {}) => [
    "yarn list --json --depth=0",
    Array.isArray(modules) === true ? " " + modules.join(" ") : ""].
    join("") } };

const STRING_PROPERTIES = ["name", "current", "wanted", "latest"];

function isNotEmptyString(value) {
  return typeof value === "string" && value.length > 0;
}

function returnIfValid(result) {
  STRING_PROPERTIES.forEach(prop => {
    if (isNotEmptyString(result[prop]) === false) {
      throw new Error("Unexpected output format of package manager");
    }
  });

  return result;
}

function tryParse(parser) {
  return (stdout, cmd) => {
    try {
      return parser(stdout);
    } catch (err) {
      err.message = `Error when trying to parse stdout from command '${cmd}': ${err.message}`;
      throw err;
    }
  };
}

function arrToObj(arr, keys) {
  return keys.reduce((obj, key, i) => {
    obj[key] = arr[i];

    return obj;
  }, {});
}

// By sorting the parsed data, we get deterministic results across different npm and yarn versions.
// As a nice side-effect, a package like eslint will always be updated before eslint-config-peerigon
// which might have a peer dependency on eslint
// See https://github.com/peerigon/updtr/issues/48
function sortByName(o1, o2) {
  return o1.name > o2.name;
}

function npmParser(stdout) {
  const trimmed = stdout.trim();

  if (trimmed.length === 0) {
    return null;
  }

  return JSON.parse(trimmed);
}

function yarnParser(stdout, wantedTypeProperty) {
  try {
    return npmParser(stdout);
  } catch (error) {
    /* in some cases (e.g. when printing the outdated result), yarn prints for each line a separate JSON object */
    /* in that case, we need to look for a { type: "table" } object which holds the interesting data to display */
  }
  const dataLine = stdout.
  split(os.EOL).
  map(line => line.trim()).
  filter(line => line !== "").
  find(line => {
    try {
      const parsedLine = JSON.parse(line);

      return parsedLine.type === wantedTypeProperty;
    } catch (error) {
      return false;
    }
  });

  if (dataLine === undefined) {
    throw new Error(`Could not find object with type === ${wantedTypeProperty}`);
  }

  return JSON.parse(dataLine);
}

const parse$1 = {
  npm: {
    outdated: tryParse(stdout => {
      const parsed = npmParser(stdout);

      if (parsed === null) {
        return [];
      }

      const names = Object.keys(parsed);

      return names.
      map(name => parsed[name]).
      map((dep, index) =>
      returnIfValid({
        name: names[index],
        current: dep.current,
        wanted: dep.wanted,
        latest: dep.latest })).


      sort(sortByName);
    }),
    list: tryParse(stdout => {
      const parsed = npmParser(stdout);

      return parsed.dependencies === undefined ?
      [] :
      Object.keys(parsed.dependencies).
      map(name => ({
        name,
        version: parsed.dependencies[name].version })).

      sort(sortByName);
    }) },

  yarn: {
    outdated: tryParse(
    stdout => {
      const parsed = yarnParser(stdout, "table");

      if (parsed === null) {
        return [];
      }

      return parsed.data.body.
      map(row => arrToObj(row, parsed.data.head)).
      map(dep =>
      returnIfValid({
        name: dep.Package,
        current: dep.Current,
        wanted: dep.Wanted,
        latest: dep.Latest })).


      sort(sortByName);
    }),

    list: tryParse(stdout => {
      const parsed = yarnParser(stdout, "tree");

      if (parsed.data.trees.length === 0) {
        return [];
      }

      return parsed.data.trees.
      map(dependency => {const _dependency$name$spli =
        dependency.name.split("@"),_dependency$name$spli2 = _slicedToArray(_dependency$name$spli, 2),name = _dependency$name$spli2[0],version = _dependency$name$spli2[1];

        if (isNotEmptyString(name) === false || isNotEmptyString(version) === false) {
          throw new Error(`Could not parse dependency name "${dependency.name}"`);
        }

        return {
          name,
          version };

      }).
      sort(sortByName);
    }) } };

// node v4 has no dedicated constants object.
// Remove this if node v4 is not supported anymore.
const FS_CONSTANTS = fs$1.constants === undefined ? fs$1 : fs$1.constants;

function checkCwd(cwd) {
  if (typeof cwd !== "string") {
    throw new RequiredOptionMissingError("cwd", cwd);
  }
}

function checkUse(use) {
  if (USE_OPTIONS.indexOf(use) === -1) {
    throw new OptionValueNotSupportedError("use", use);
  }
}

function checkUpdateTo(updateTo) {
  if (UPDATE_TO_OPTIONS.indexOf(updateTo) === -1) {
    throw new OptionValueNotSupportedError("updateTo", updateTo);
  }
}

function checkSave(save) {
  if (SAVE_OPTIONS.indexOf(save) === -1) {
    throw new OptionValueNotSupportedError("save", save);
  }
}

function checkForYarnWithCustomReg(packageManager, registry) {
  if (packageManager === "yarn" && registry !== undefined) {
    throw new YarnWithCustomRegistryError();
  }
}

class Updtr extends EventEmitter {
  // TODO: Add typings for UpdtrConfig
  // eslint-disable-next-line
  /**
   * The config passed-in here should look identically to the CLI config.
   * Dash-cased properties should be renamed to camelCased.
   * The goal is to replicate the API of the CLI as close as possible so users don't
   * have to guess the options.
   *
   * @param {UpdtrConfig} config
   */
  constructor(config) {
    super();

    const cwd = config.cwd;
    const registry = config.registry;
    const packageManager = config.use === undefined ?
    USE_OPTIONS[0] :
    config.use;
    const updateTo = config.updateTo === undefined ?
    UPDATE_TO_OPTIONS[0] :
    config.updateTo;
    const exclude = Array.isArray(config.exclude) === true ?
    config.exclude :
    [];
    const save = config.save === undefined ? SAVE_OPTIONS[0] : config.save;

    checkCwd(cwd);
    checkUse(packageManager);
    checkForYarnWithCustomReg(packageManager, registry);
    checkUpdateTo(updateTo);
    checkSave(save);

    this.config = {
      cwd,
      use: packageManager,
      exclude,
      test: config.test,
      registry,
      updateTo,
      save };

    this.cmds = cmds[packageManager];
    this.parse = parse$1[packageManager];

    if (typeof config.test === "string") {
      this.cmds = _objectSpread({},
      this.cmds, {
        test: () => config.test });

    }
  }
  canAccessPackageJson() {var _this = this;return _asyncToGenerator(function* () {
      let result = true;

      try {
        yield fs$1.access(
        path.join(_this.config.cwd, "package.json"),
        FS_CONSTANTS.R_OK | FS_CONSTANTS.W_OK // eslint-disable-line no-bitwise
        );
      } catch (err) {
        result = false;
      }

      return result;})();
  }
  exec(cmd) {
    return exec(this.config.cwd, cmd);
  }
  readFile(filenameInCwd) {
    return fs$1.readFile(path.join(this.config.cwd, filenameInCwd), "utf8");
  }
  writeFile(filenameInCwd, contents) {
    return fs$1.writeFile(
    path.join(this.config.cwd, filenameInCwd),
    contents);

  }
  dispose() {
    this.removeAllListeners();
  }}

function create(config) {
  return new Updtr(config);
}

function

start() {return _start.apply(this, arguments);}function _start() {_start = _asyncToGenerator(function* () {
    const cwd = process.cwd();
    const config = _objectSpread({}, argv);
    const reporterConfig = {
      stream: process.stdout,
      testStdout: argv.testStdout };

    const reporter = reporters[argv.reporter];

    config.cwd = cwd;

    const updtr = create(config);

    reporter(updtr, reporterConfig);
    try {
      yield run(updtr);
    } catch (err) {
      updtr.emit("error", err);
    }
  });return _start.apply(this, arguments);}

start();
